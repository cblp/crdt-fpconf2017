<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>CRDT &lt;> Haskell</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <style media="screen">
      section img.element {
        background: transparent;
        border: 0;
        vertical-align: middle;
      }
      table.td-center td {
        text-align: center;
      }
      table.figure td {
        width: 20%;
        text-align: center;
        font-size: 500%;
        padding: 0;
      }
      .term {color: #99f;}
      .term-def {color: #9f9;}
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          # CRDT &lt;> Haskell
          –Æ—Ä–∏–π –°—ã—Ä–æ–≤–µ—Ü–∫–∏–π, –ù–∏–∫–æ–ª–∞–π –õ–æ–≥–∏–Ω–æ–≤
        </section>

        <section>
          <table class=figure>
            <tr>
              <td>
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h2>–†–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                <span data-fragment-index=1 style="position: absolute;" class="current-visible">‚ùå</span>
                <span data-fragment-index=2 style="position: absolute;">‚öîÔ∏è</span>
                <span data-fragment-index=3 style="position: absolute;">üëÆ</span>
                ‚áÜ
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h2>CRDT ‚Äî Conflict-free Replicated Data Type</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                ü§ù
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
          <a href="https://hackage.haskell.org/package/crdt">hackage:crdt</a>
        </section>

        <section>
          <h2>–ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>
          <img
            alt="semilattice"
            class="element"
            src="semilattice.png"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <p>
            <strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ 1.</strong>
            –ú–Ω–æ–∂–µ—Å—Ç–≤–æ $A$ —Å –æ–ø–µ—Ä–∞—Ü–∏–µ–π $(‚ãÑ)$ ‚Äî
            <em class="term-def">–ø–æ–ª—É–≥—Ä—É–ø–ø–∞</em>,
            –µ—Å–ª–∏ —ç—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è <em class="term">–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∞</em>.
          </p>
          <p>
            <strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ 2.</strong>
            –ü–æ–ª—É–≥—Ä—É–ø–ø–∞ $(A, (‚ãÑ))$ ‚Äî <em class="term-def">–ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</em>,
            –µ—Å–ª–∏ —ç—Ç–∞ —ç—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è <em class="term">–∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–∞</em>
            –∏ <em class="term">–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞</em>.
          </p>
        </section>

        <section data-markdown>
          ## –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å

          $$
          x ‚ãÑ x = x
          $$

          –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–µ –ø–æ—Ä—Ç–∏—Ç –¥–∞–Ω–Ω—ã–µ
        </section>

        <section data-markdown>
          ## –ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

          $$
          x ‚ãÑ y = y ‚ãÑ x
          $$

          –ú–æ–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤ –ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏
        </section>

        <section data-markdown>
          ## –ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å

          $$
          (x ‚ãÑ y) ‚ãÑ z = x ‚ãÑ (y ‚ãÑ z)
          $$

          –ú–æ–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤ –ª—é–±–æ–º –ø–æ—Ä—è–¥–∫–µ
        </section>

        <section data-markdown>
          ## –ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞ =
          ## _Convergent_ RDT (CvRDT)
        </section>

        <section>
          <h2>(–º–Ω–æ–∂–µ—Å—Ç–≤–∞, $(\cup)$) ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>

          $$
          (X \cup Y) \cup Z = X \cup (Y \cup Z) \\
          X \cup Y = Y \cup X \\
          X \cup X = X
          $$
        </section>

        <section>
          <h2>$(‚Ñù, \max)$ ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>

          $$
          \max (\max (x, y), z) = \max (x, \max (y, z)) \\
          \max (x, y) = \max (y, x) \\
          \max (x, x) = x
          $$
        </section>

        <section>
          <h2>$(‚Ñù, (+))$ ‚Äî –ø–æ–ª—É–≥—Ä—É–ø–ø–∞</h2>

          $$
          (x + y) + z = x + (y + z)
          $$

          <h2>–Ω–æ –Ω–µ –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>

          $$
          x + x \ne x
          $$
        </section>

        <section data-markdown>
          ## –ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞ –≤ Haskell

              class Semigroup a where
                  (&lt;>) :: a -> a -> a

              class Semigroup a => Semilattice a

              type CvRDT = Semilattice
        </section>

        <section data-markdown>
          ## `Set` ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞

              instance Ord a => Semigroup (Set a) where
                  (&lt;>) = Set.union

              instance Ord a => Semilattice (Set a)

              -- instance Ord a => CvRDT (Set a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        </section>

        <section data-markdown>
          ## `Max` ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞

              newtype Max a = Max a

              instance Ord a => Semigroup (Max a) where
                  Max x &lt;> Max y = Max (max x y)

              instance Ord a => Semilattice (Max a)

              -- instance Ord a => CvRDT (Max a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
        </section>

        <section>
          <h2><code>LWW</code> (Last Write Wins)</h2>

          <pre><code>
            data LWW a = LWW
                { value     :: a
                , timestamp :: Timestamp
                }

            instance Ord (LWW a) where
                LWW{timestamp = t1} &lt;= LWW{timestamp = t2} =
                    t1 &lt;= t2

            instance Semigroup (LWW a) where
                (&lt;>) = max

            instance Semilattice (LWW a)

            -- instance CvRDT (LWW a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section>
          <h2>–ü—Ä–∏–º–µ—Ä –∏–∑ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ ‚Äî —Å—á—ë—Ç—á–∏–∫ –ª–∞–π–∫–æ–≤</h2>

          <table class="td-center">
            <tr>
              <td>
                <code>
                  <span class=f3>{</span><span class=f1>0:</span><span
                  class=f0>37175</span><span class=f3>, &nbsp;1:18267,
                  &nbsp;2:52733}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0:37175,</span>
                  <span class=f1>&nbsp;1:</span><span class=f0>18267</span><span
                  class=f3>, &nbsp;2:52733}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0:37175, &nbsp;1:18267,</span>
                  <span class=f1>&nbsp;2:</span><span class=f0>52733</span><span
                  class=f3>}<br>&uarr;</span>
                </code>
              </td>
            </tr>
          </table>

          <p class=f2>
            &darr;<br>
            <code>{0:37175, 1:18267, 2:52733}</code>
          </p>
        </section>

        <section>
          <h2>Grow-only counter</h2>

          <pre><code>
            newtype GCounter = G (Map ReplicaId Natural)

            increment :: ReplicaId -> GCounter -> GCounter
            increment replicaId (G m) =
                G (Map.insertWith (+) replicaId 1 m)

            query :: GCounter -> Natural
            query (G m) = sum m

            instance Semigroup GCounter where
                G x &lt;> G y = G (Map.unionWith max x y)

            instance Semilattice GCounter

            -- instance CvRDT GCounter -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section data-markdown>
          ## –ü—Ä–æ–±–ª–µ–º–∞ CvRDT ‚Äî —Ä–∞–∑–º–µ—Ä –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        </section>

        <section>
          <h2><em>Commutative</em> RDT (CmRDT)</h2>
          <img
            alt="CmRDT"
            class=element
            height="500px"
            src="CmRDT-overview.svg"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <pre><code>
            class CausalOrd a where
                affects :: a -> a -> Bool

            class CausalOrd op => CmRDT op where
                type Intent op

                type Payload op

                precondition :: Intent op -> Payload op -> Bool

                makeOp       :: Intent op -> Timestamp -> op

                apply        :: op -> Payload op -> Payload op
          </code></pre>
        </section>

        <section>
          <pre><code>
            data LWW a = LWW
                { value     :: a
                , timestamp :: Timestamp
                }

            instance CausalOrd (LWW a) where
                affects _ _ = False

            instance Eq a => CmRDT (LWW a) where
                type Intent  (LWW a) = a
                type Payload (LWW a) = LWW a
                makeOp = LWW
                apply = (&lt;>)
          </code></pre>
        </section>

        <section>
          <pre><code>
            data Counter = Increment | Decrement

            instance CausalOrd (LWW a) where
                affects _ _ = False

            instance CmRDT Counter where
                type Intent  Counter = Counter

                type Payload Counter = Integer

                apply op x = case op of
                    Increment -> x + 1
                    Decrement -> x - 1
          </code></pre>
        </section>

        <section>
          <pre><code>
            data TwoPSet a = Add a | Remove a

            instance Eq a => CausalOrd (TwoPSet a) where
                Remove a  `affects`  Add b  =  a == b
                _         `affects`  _      =  False

            instance Ord a => CmRDT (TwoPSet a) where
                type Intent  (TwoPSet a) = TwoPSet a

                type Payload (TwoPSet a) = Set a

                precondition op s = case op of
                    Add    _  ->  True
                    Remove a  ->  Set.member a s

                apply op s = case op of
                    Add    a  ->  Set.insert a s
                    Remove a  ->  Set.delete a s
          </code></pre>
        </section>

        <section data-markdown>
          ## –ó–∞–∫–æ–Ω—ã –∫–ª–∞—Å—Å–æ–≤ –Ω–µ –≤—ã—Ä–∞–∂–∞—é—Ç—Å—è –≤ Haskell
        </section>

        <section>
          <h2>Property-based testing</h2>

          <pre><code>
            associativity  =  \x y z  ->  (x &lt;> y) &lt;> z == x &lt;> (y &lt;> z)

            commutativity  =  \x y  ->  x &lt;> y == y &lt;> x

            idempotency    =  \x  ->  x &lt;> x == x
          </code></pre>
          <pre class="fragment"><code>
            associativity:
              +++ OK, passed 100 tests.
            commutativity:
              +++ OK, passed 100 tests.
            idempotency:
              +++ OK, passed 100 tests.
          </code></pre>
        </section>

        <section>
          <ul>
            <li><a href="http://hackage.haskell.org/package/ClassLaws">hackage:ClassLaws</a></li>
            <li><a href="http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/ClassLaws">wiki.portal.chalmers.se/cse/pmwiki.php/FP/ClassLaws</a> (2012)</li>
          </ul>
        </section>

        <section>
          <pre><code>
          </code></pre>
        </section>

        <!-- TODO: Type-level Haskell -->

        <!-- TODO: Liquid haskell -->

        <!-- TODO http://www.cse.chalmers.se/~jomoa/papers/typeclasslaws.pdf -->
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      document.querySelectorAll('[data-fragment-index]').forEach(e => {
        e.className += ' fragment';
      });

      document.querySelectorAll('code').forEach(e => {e.dataset.trim = '';});

      fragmentColors = ['#f55', '#ff5', '#5f5', '#5ff', '#55f', '#f5f'];
      for (var i = 0; i < 10; ++i) {
        document.querySelectorAll('[class=f' + i + ']').forEach(f => {
          f.className += ' fragment';
          f.dataset.fragmentIndex = i;
          f.style.color = fragmentColors[i];
        });
      }

      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
              hljs.configure({languages: ['haskell']});
              hljs.initHighlightingOnLoad();
            }
          },
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/math/math.js' },
          { src: 'plugin/notes/notes.js', async: true },
        ],
        history: true,
        slideNumber: true,
        transition: 'none',
      });
    </script>
  </body>
</html>
