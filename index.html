<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>CRDT &lt;> Haskell</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="lib/font/my/styles.css">
    <!-- <link rel="stylesheet" href="lib/font/mfizz/font-mfizz.css"> -->
    <!-- <link rel="stylesheet" href="lib/font/awesome/css/font-awesome.min.css"> -->

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <style>
      section img.element {
        background: transparent;
        border: 0;
        vertical-align: middle;
      }
      table.td-center td {
        text-align: center;
      }
      table.figure td {
        width: 33%;
        text-align: center;
        font-size: 500%;
        padding: 0;
      }
      .term {color: #99f;}
      .term-def {color: #9f9;}
      p.formula-large {font-size: 200%;}
      p.formula-medium {font-size: 130%;}
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>CRDT <code>&lt;></code> Haskell</h1>
          <h2>–Æ—Ä–∏–π –°—ã—Ä–æ–≤–µ—Ü–∫–∏–π</h2>
          <h2>–ù–∏–∫–æ–ª–∞–π –õ–æ–≥–∏–Ω–æ–≤</h2>
        </section>

        <section>
          <table class=figure>
            <tr>
              <td>
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h2>–†–∞—Å–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞<br>&nbsp;</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                <span data-fragment-index=1 style="position: absolute; width: 23%; text-align: center;" class="current-visible">‚áÜ</span>
                <span data-fragment-index=2 style="position: absolute; width: 23%; text-align: center;" class="current-visible">‚ùå</span>
                <span data-fragment-index=3 style="position: absolute; width: 23%; text-align: center;" class="current-visible">‚öîÔ∏è</span>
                <span data-fragment-index=4>üëÆ</span>
                <!-- TODO: replace emojis with images; remove style hack -->
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h2>CRDT ‚Äî Conflict-free Replicated Data Type</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                ü§ù
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
        </section>

        <section>
          <h1>
            <a href="https://hackage.haskell.org/package/crdt">
              <code class="icon-haskell">crdt</code>
            </a>
          </h1>
          <h2>
            <code style="white-space: nowrap;">stack repl --package crdt</code>
          </h2>
        </section>

        <section>
          <h1>–ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h1>
          <img
            alt="semilattice"
            class="element"
            src="semilattice.png"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <p>
            <strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ 1.</strong>
            –ú–Ω–æ–∂–µ—Å—Ç–≤–æ $A$ —Å –æ–ø–µ—Ä–∞—Ü–∏–µ–π $(‚ãÑ)$ ‚Äî
            <em class="term-def">–ø–æ–ª—É–≥—Ä—É–ø–ø–∞</em>,
            –µ—Å–ª–∏ —ç—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è <em class="term">–∞—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–∞</em>.
          </p>
          <p>
            <strong>–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ 2.</strong>
            –ü–æ–ª—É–≥—Ä—É–ø–ø–∞ $(A, (‚ãÑ))$ ‚Äî <em class="term-def">–ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</em>,
            –µ—Å–ª–∏ —ç—Ç–∞ —ç—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è <em class="term">–∫–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–∞</em>
            –∏ <em class="term">–∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞</em>.
          </p>
        </section>

        <section>
          <h1>–ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å</h1>
          <p class="formula-large">$ x ‚ãÑ x = x $</p>
          <h2>–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–µ&nbsp;–ø–æ—Ä—Ç–∏—Ç –¥–∞–Ω–Ω—ã–µ</h2>
        </section>

        <section>
          <h1>–ö–æ–º–º—É—Ç–∞—Ç–∏–≤–Ω–æ—Å—Ç—å</h1>
          <p class="formula-large">$ x ‚ãÑ y = y ‚ãÑ x $</p>
          <h2>–ú–æ–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤&nbsp;–ª—é–±–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏</h2>
        </section>

        <section>
          <h1>–ê—Å—Å–æ—Ü–∏–∞—Ç–∏–≤–Ω–æ—Å—Ç—å</h1>
          <p class="formula-large">$ (x ‚ãÑ y) ‚ãÑ z = x ‚ãÑ (y ‚ãÑ z) $</p>
          <h2>–ú–æ–∂–Ω–æ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å –≤&nbsp;–ª—é–±–æ–º –ø–æ—Ä—è–¥–∫–µ</h2>
        </section>

        <section data-markdown>
          # –ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞ =
          # _Convergent_ RDT (CvRDT)
        </section>

        <section>
          <h1>(–º–Ω–æ–∂–µ—Å—Ç–≤–∞, $(\cup)$)</h1>
          <p class="formula-medium">
            $ (X \cup Y) \cup Z = X \cup (Y \cup Z) $<br>
            $ X \cup Y = Y \cup X $<br>
            $ X \cup X = X $
          </p>
        </section>

        <section>
          <h1>(‚Ñù, $\max$)</h1>
          <p style="font-size: 130%;">
            $ \max (\max (x, y), z) = \max (x, \max (y, z)) $<br>
            $ \max (x, y) = \max (y, x) $<br>
            $ \max (x, x) = x $
          </p>
        </section>

        <section>
          <h2>(‚Ñù, (+)) ‚Äî –ø–æ–ª—É–≥—Ä—É–ø–ø–∞</h2>
          <p class="formula-large">$ (x + y) + z = x + (y + z) $</p>
          <h2>–Ω–æ –Ω–µ –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>
          <p class="formula-large">$ \cancel{x + x = x} $</p>
        </section>

        <section>
          <h2>–ü–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞ –≤ Haskell</h2>

          <code class="icon-package">base</code>
          <pre><code>
          -- | associativity: (x &lt;> y) &lt;> z == x &lt;> (y &lt;> z)
          class Semigroup a where
              (&lt;>) :: a -> a -> a
          </code></pre>

          <code class="icon-package">crdt</code>
          <pre><code>
          -- | commutativity: x &lt;> y == y &lt;> x
          --   idempotency: x &lt;> x == x
          class Semigroup a => Semilattice a

          type CvRDT = Semilattice
          </code></pre>
        </section>

        <section>
          <h2><code>Set</code> ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>

          <code class="icon-package">base</code>
          <pre><code>
          instance Ord a => Semigroup (Set a) where
              (&lt;>) = union
          </code></pre>

          <code class="icon-package">crdt</code>
          <pre><code>
          instance Ord a => Semilattice (Set a)

          -- instance Ord a => CvRDT (Set a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section>
          <h2><code>Max</code> ‚Äî –ø–æ–ª—É—Ä–µ—à—ë—Ç–∫–∞</h2>

          <code class="icon-package">base</code>
          <pre><code>
          newtype Max a = Max a

          instance Ord a => Semigroup (Max a) where
              Max x &lt;> Max y = Max (max x y)
          </code></pre>

          <code class="icon-package">crdt</code>
          <pre><code>
          instance Ord a => Semilattice (Max a)

          -- instance Ord a => CvRDT (Max a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section>
          <h2><code>LWW</code> (Last Write Wins)</h2>
          <pre><code>
            data LWW a = LWW
                { value     :: a
                , timestamp :: Timestamp
                }

            instance Ord (LWW a) where
                LWW{timestamp = t1} &lt;= LWW{timestamp = t2} =
                    t1 &lt;= t2

            instance Semigroup (LWW a) where
                (&lt;>) = max

            instance Semilattice (LWW a)

            -- instance CvRDT (LWW a) -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section>
          <h2>–ü—Ä–∏–º–µ—Ä –∏–∑ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ ‚Äî —Å—á—ë—Ç—á–∏–∫ –ª–∞–π–∫–æ–≤</h2>

          <table class="td-center">
            <tr>
              <td>
                <code>
                  <span class=f3>{</span><span class=f1>0:</span>
                  <span class=f0>717</span><span class=f3>, &nbsp;1: 826,
                  &nbsp;2: 273}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0: 717,</span>
                  <span class=f1>&nbsp;1:</span>
                  <span class=f0>826</span><span class=f3>,
                  &nbsp;2: 273}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0: 717, &nbsp;1: 826,</span>
                  <span class=f1>&nbsp;2:</span>
                  <span class=f0>273</span><span class=f3>}<br>&uarr;</span>
                </code>
              </td>
            </tr>
          </table>

          <p class=f2>
            &darr;<br>
            <code>{0: 717, 1: 826, 2: 273}</code>
          </p>
        </section>

        <section>
          <h2>Grow-only counter</h2>

          <pre><code>
            newtype GCounter = G (Map ReplicaId Natural)

            increment :: ReplicaId -> GCounter -> GCounter
            increment replicaId (G m) =
                G (insertWith (+) replicaId 1 m)

            query :: GCounter -> Natural
            query (G m) = sum m

            instance Semigroup GCounter where
                G x &lt;> G y = G (unionWith max x y)

            instance Semilattice GCounter

            -- instance CvRDT GCounter -- –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
          </code></pre>
        </section>

        <section>
          <h1>–ü—Ä–æ–±–ª–µ–º–∞ CvRDT&nbsp;‚Äî —Ä–∞–∑–º–µ—Ä –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö</h1>
        </section>

        <section>
          <h2><em>Commutative</em> RDT (CmRDT)</h2>
          <img
            alt="CmRDT"
            class=element
            height="500px"
            src="CmRDT-overview.svg"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <h2>CmRDT –≤ Haskell</h2>
          <pre><code>
            class CausalOrd a where
                affects :: a -> a -> Bool

            class CausalOrd op => CmRDT op where
                type Payload op
                apply :: op -> Payload op -> Payload op

                type Intent op
                makeOp :: Intent op -> Payload op -> Maybe (Process op)
          </code></pre>
        </section>

        <section>
          <h2><code>LWW</code> (Last Write Wins)</h2>
          <pre><code>
            data LWW a = LWW
                { value     :: a
                , timestamp :: Timestamp
                }

            instance CausalOrd (LWW a) where
                affects _ _ = False

            instance Eq a => CmRDT (LWW a) where
                type Payload (LWW a) = LWW a
                apply = (&lt;>)

                type Intent (LWW a) = a
                makeOp value state = Just (assign value state)
          </code></pre>
        </section>

        <section>
          <h2>Counter</h2>
          <pre><code>
            data Counter = Increment | Decrement

            instance CausalOrd (LWW a) where
                affects _ _ = False

            instance CmRDT Counter where
                type Payload Counter = Integer
                apply op x = case op of
                    Increment -> x + 1
                    Decrement -> x - 1

                type Intent Counter = Counter
                makeOp i _ = Just (pure i)
          </code></pre>
        </section>

        <section>
          <h2>2P-Set (2-phase set)</h2>
          <pre><code>
            data TwoPSet a = Add a | Remove a

            instance Eq a => CausalOrd (TwoPSet a) where
                Remove a  `affects`  Add b  =  a == b
                _         `affects`  _      =  False

            instance Ord a => CmRDT (TwoPSet a) where
                type Payload (TwoPSet a) = Set a
                apply op s = case op of
                    Add    a  ->  insert a s
                    Remove a  ->  delete a s

                type Intent (TwoPSet a) = TwoPSet a
                makeOp op s = case op of
                    Add    _  ->  Just (pure op)
                    Remove a  ->  if a `member` s then
                                      Just (pure op)
                                  else
                                      Nothing
          </code></pre>
        </section>

        <section data-markdown>
          # –ö–∞–∫ —É–±–µ–¥–∏—Ç—å —Å–µ–±—è, —á—Ç–æ –∫–æ–¥ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π?
        </section>

        <section>
          <h2>–í—Å–µ–º –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ –∑–∞–∫–æ–Ω—ã –∫–ª–∞—Å—Å–æ–≤</h2>
          <h1>Haskell <nobr>–Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç</nobr></h1>
        </section>

        <section>
          <h2>Property-based testing (QuickCheck)</h2>

          <pre><code>
            associativity  =  \x y z  ->  (x &lt;> y) &lt;> z == x &lt;> (y &lt;> z)

            commutativity  =  \x y  ->  x &lt;> y == y &lt;> x

            idempotency    =  \x  ->  x &lt;> x == x
          </code></pre>
          <pre><code>
            associativity:
              +++ OK, passed 100 tests.
            commutativity:
              +++ OK, passed 100 tests.
            idempotency:
              +++ OK, passed 100 tests.
          </code></pre>
        </section>

        <section>
          <ul>
            <li><a href="http://hackage.haskell.org/package/ClassLaws">hackage:ClassLaws</a></li>
            <li><a href="http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/ClassLaws">wiki.portal.chalmers.se/<wbr>cse/<wbr>pmwiki.php/<wbr>FP/<wbr>ClassLaws</a> (2012)</li>
          </ul>

          <!-- TODO: QuickCheck laws -->

          <!-- TODO: prove laws with SAT solvers -->
        </section>

        <!-- TODO: Liquid haskell -->

        <section>
          <h1>Type-level</h1>
          <p>
            Justin Le,<br>
            <a href="https://blog.jle.im/entry/verified-instances-in-haskell.html">blog.jle.im/<wbr>entry/<wbr>verified-instances-in-haskell</a>
          </p>
        </section>

        <section>
          <h2>Ah, type-level Haskell...</h2>
          <pre><code>
            {-# LANGUAGE DataKinds #-}
            {-# LANGUAGE FlexibleInstances #-}
            {-# LANGUAGE GADTs #-}
            {-# LANGUAGE OverloadedStrings #-}
            {-# LANGUAGE PolyKinds #-}
            {-# LANGUAGE QuasiQuotes #-}
            {-# LANGUAGE RankNTypes #-}
            {-# LANGUAGE ScopedTypeVariables #-}
            {-# LANGUAGE TemplateHaskell #-}
            {-# LANGUAGE TypeFamilies #-}
            {-# LANGUAGE TypeOperators #-}
            {-# LANGUAGE UndecidableInstances #-}
          </code></pre>
        </section>

        <section>
          <h2>–ü–æ–ª—É–≥—Ä—É–ø–ø–∞ —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ–º</h2>
          <pre><code>
            class Semigroup a where
                type (x :: a) &lt;> (y :: a) :: a

                (%&lt;>) ::
                    Sing (x :: a) -> Sing (y :: a) -> Sing (x &lt;> y)

                associativity ::
                    Sing (x :: a) -> Sing (y :: a) -> Sing (z :: a) ->
                    ((x &lt;> y) &lt;> z) :~: (x &lt;> (y &lt;> z))

            (&lt;>) :: (SingKind m, Semigroup m) =>
                    Demote m -> Demote m -> Demote m
            x &lt;> y = withSomeSing x $ \sX ->
                         withSomeSing y $ \sY ->
                             fromSing (sX %&lt;> sY)
          </code></pre>
        </section>

        <section>
          <h2>–°–ø–∏—Å–æ–∫ —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ–º</h2>
          <pre><code>
            instance Semigroup [a] where
                type xs &lt;> ys = xs :++ ys
                (%&lt;>) = (%:++)

                associativity xs ys zs = case xs of
                    SNil -> Refl
                    SCons _ xs' ->
                        case associativity xs' ys zs of
                            Refl -> Refl
          </code></pre>
        </section>

        <section>
          <h2><code>Max</code> —Å –¥–æ–∫–∞–∑–∞—Ç–µ–ª—å—Å—Ç–≤–æ–º</h2>
          <pre><code>
            instance SOrd a => Semigroup (Max a) where
                type 'Max x &lt;> 'Max y = 'Max (Singletons.Max x y)
                SMax x %&lt;> SMax y = SMax (sMax x y)
                associativity = undefined
          </code></pre>
        </section>

        <section>
          <h2>–í –¥–µ–π—Å—Ç–≤–∏–∏</h2>
          <pre><code class="haskell">
            Œª> print ([1, 2] &lt;> [3] :: [Integer])
            [1,2,3]
          </code></pre>
          <pre class="fragment"><code class="haskell">
            Œª> print ([1, 2] &lt;> [3] :: [Int])
            error:
                ‚Ä¢ Couldn't match type ‚ÄòDemote a‚Äô with ‚ÄòInt‚Äô
                  Expected type: [Int]
                    Actual type: Demote [a]
                  The type variable ‚Äòa‚Äô is ambiguous
          </code></pre>
          <pre class="fragment"><code class="haskell">
            Œª> print ([1, 2] &lt;> [-3] :: [Integer])
            *** Exception: Negative singleton nat
          </code></pre>
        </section>

        <!-- TODO http://www.cse.chalmers.se/~jomoa/papers/typeclasslaws.pdf -->

        <!-- TODO: https://github.com/LeventErkok/sbvPlugin -->

        <section data-markdown>
          ## –í—ã–≤–æ–¥—ã

          1. Property-based —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî –≤–µ—â—å
          1. Dependent Haskell ‚Äî –Ω–µ —Å–µ–≥–æ–¥–Ω—è
          <!-- TODO: –µ—â—ë -->
        </section>

        <section>
          <h1>–í–æ–ø—Ä–æ—Å—ã</h1>
          <h2>–Æ—Ä–∏–π –°—ã—Ä–æ–≤–µ—Ü–∫–∏–π</h2>
          <h2>–ù–∏–∫–æ–ª–∞–π –õ–æ–≥–∏–Ω–æ–≤</h2>
          <h2>
            <a href="https://hackage.haskell.org/package/crdt">
              <code class="icon-haskell">crdt</code>
            </a>
          </h2>
          <h2>
            <a href="https://github.com/cblp/crdt">
              <code class="icon-github">cblp/crdt</code>
            </a>
          </h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      document.querySelectorAll('[data-fragment-index]').forEach(e => {
        e.className += ' fragment';
      });

      document.querySelectorAll('code').forEach(e => {e.dataset.trim = '';});

      fragmentColors = ['#f55', '#ff5', '#5f5', '#5ff', '#55f', '#f5f'];
      for (var i = 0; i < 10; ++i) {
        document.querySelectorAll('[class=f' + i + ']').forEach(f => {
          f.className += ' fragment';
          f.dataset.fragmentIndex = i;
          f.style.color = fragmentColors[i];
        });
      }

      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
              hljs.configure({languages: ['haskell']});
              hljs.initHighlightingOnLoad();
            }
          },
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/math/math.js' },
          { src: 'plugin/notes/notes.js', async: true },
        ],
        history: true,
        slideNumber: true,
        transition: 'none',
      });
    </script>
  </body>
</html>
