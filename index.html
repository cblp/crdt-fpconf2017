<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>CRDT &lt;> Haskell</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <link rel="stylesheet" href="lib/font/my/styles.css">
    <style>
      [data-icon]:before {
        vertical-align: middle;
      }

      [class^="icon-"]:before,
      [class*=" icon-"]:before {
        vertical-align: middle;
      }
    </style>

    <!-- <link rel="stylesheet" href="lib/font/mfizz/font-mfizz.css"> -->
    <!-- <link rel="stylesheet" href="lib/font/awesome/css/font-awesome.min.css"> -->

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <style>
      section img.element {
        background: transparent;
        border: 0;
        vertical-align: middle;
      }
      table.td-center td {
        text-align: center;
      }
      table.figure td {
        width: 33%;
        text-align: center;
        font-size: 500%;
        padding: 0;
      }
      .term {color: #99f;}
      .term-def {color: #9f9;}
      p.formula-large {font-size: 200%;}
      p.formula-medium {font-size: 130%;}
    </style>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>CRDT <code>&lt;></code> Haskell</h1>
          <h2>Юрий Сыровецкий</h2>
          <h2>Николай Логинов</h2>
        </section>

        <section data-markdown>
          ## Московский Химический Лицей
          ## (школа 1303)
        </section>

        <section data-background-image="intro-conflict-1.jpg">
        </section>

        <section data-background-image="intro-conflict-2.png">
        </section>

        <section>
          <h2>Данные<br>&nbsp;</h2>
          <table class=figure>
            <tr>
              <td></td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td></td>
            </tr>
          </table>
        </section>

        <section>
          <h2>Распределённые данные<br>&nbsp;</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                <span
                  class="fade-out icon-arrows-h"
                  data-fragment-index=1
                  style="position: absolute;">
                </span>
                <span
                  class="current-visible icon-times"
                  data-fragment-index=1
                  style="color: red; position: absolute;">
                </span>
                <span
                  class="current-visible icon-exclamation-triangle"
                  data-fragment-index=2
                  style="color: yellow; position: absolute;">
                </span>
                <span class="icon-ambulance" data-fragment-index=3></span>
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
        </section>

        <!-- TODO: иллюстрация конфликта -->
        <!-- TODO: примеры из реальности: непрочитанные сообщения -- а потом нет -->

        <section>
          <h2>CRDT — Conflict-free Replicated Data Type</h2>
          <table class=figure>
            <tr>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
              <td>
                <i class="icon-like"></i>
              </td>
              <td>
                <img class="element" src="database.png" alt="DB" border=0>
              </td>
            </tr>
          </table>
        </section>

        <section data-markdown>
          1. Модели CRDT
              - State-based (Convergent)
              - Op-based (Commutative)
          1. Реализация
          1. Проблемы и решения
        </section>

        <section>
          <h1>
            <a href="https://hackage.haskell.org/package/crdt">
              <i class="icon-haskell"></i> <code>crdt</code>
            </a>
          </h1>
          <h2>
            <code style="white-space: nowrap;">stack repl --package crdt</code>
          </h2>
        </section>

        <!-- TODO: переход к полурешёткам -->

        <section>
          <h1>Полурешётка</h1>
          <img
            alt="semilattice"
            class="element"
            src="semilattice.png"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <!-- TODO: продублировать формулы на первом слайде -->
          <p>
            <strong>Определение 1.</strong>
            Множество $A$ с операцией $(⋄)$ —
            <em class="term-def">полугруппа</em>,
            если эта операция <em class="term">ассоциативна</em>.
          </p>
          <p>
            <strong>Определение 2.</strong>
            Полугруппа $(A, (⋄))$ — <em class="term-def">полурешётка</em>,
            если эта эта операция <em class="term">коммутативна</em>
            и <em class="term">идемпотентна</em>.
          </p>
        </section>

        <section>
          <h1>Идемпотентность</h1>
          <p class="formula-large">$ x ⋄ x = x $</p>
          <h2>Синхронизация не&nbsp;портит данные</h2>
        </section>

        <section>
          <h1>Коммутативность</h1>
          <p class="formula-large">$ x ⋄ y = y ⋄ x $</p>
          <h2>Можно синхронизировать в&nbsp;любом направлении</h2>
        </section>

        <section>
          <h1>Ассоциативность</h1>
          <p class="formula-large">$ (x ⋄ y) ⋄ z = x ⋄ (y ⋄ z) $</p>
          <h2>Можно синхронизировать в&nbsp;любом порядке</h2>
        </section>

        <section data-markdown>
          # Полурешётка =
          # _Convergent_ RDT
          ## (CvRDT, state-based)
        </section>

        <section>
          <h1>(множества, (∪))</h1>
          <p class="formula-medium">
            $ (X \cup Y) \cup Z = X \cup (Y \cup Z) $<br>
            $ X \cup Y = Y \cup X $<br>
            $ X \cup X = X $
          </p>
        </section>

        <section>
          <h1>(ℝ, max)</h1>
          <p style="font-size: 130%;">
            $ \max (\max (x, y), z) = \max (x, \max (y, z)) $<br>
            $ \max (x, y) = \max (y, x) $<br>
            $ \max (x, x) = x $
          </p>
        </section>

        <section>
          <h2>(ℝ, (+)) — полугруппа</h2>
          <p class="formula-large">$ (x + y) + z = x + (y + z) $</p>
          <h2>но не полурешётка</h2>
          <p class="formula-large">$ \cancel{x + x = x} $</p>
        </section>

        <section>
          <h2>Полурешётка в Haskell</h2>

          <i class="icon-package"></i> <code>base</code>
          <pre><code>
          -- | associativity: (x &lt;> y) &lt;> z == x &lt;> (y &lt;> z)
          class Semigroup a where
              (&lt;>) :: a -> a -> a
          </code></pre>

          <i class="icon-package"></i> <code>crdt</code>
          <pre><code>
          -- | commutativity: x &lt;> y == y &lt;> x
          --   idempotency: x &lt;> x == x
          class Semigroup a => Semilattice a

          type CvRDT = Semilattice
          </code></pre>
        </section>

        <section>
          <h2><code>Set</code> — полурешётка</h2>

          <i class="icon-package"></i> <code>base</code>
          <pre><code>
          instance Ord a => Semigroup (Set a) where
              (&lt;>) = union
          </code></pre>

          <i class="icon-package"></i> <code>crdt</code>
          <pre><code>
          instance Ord a => Semilattice (Set a)

          -- instance Ord a => CvRDT (Set a) -- автоматически
          </code></pre>
        </section>

        <section>
          <h2><code>Max</code> — полурешётка</h2>

          <i class="icon-package"></i> <code>base</code>
          <pre><code>
          newtype Max a = Max a

          instance Ord a => Semigroup (Max a) where
              Max x &lt;> Max y = Max (max x y)
          </code></pre>

          <i class="icon-package"></i> <code>crdt</code>
          <pre><code>
          instance Ord a => Semilattice (Max a)

          -- instance Ord a => CvRDT (Max a) -- автоматически
          </code></pre>
        </section>

        <!-- TODO: пример для максимума -- счётчик? -->

        <section>
          <h2><code>LWW</code> (Last Write Wins)</h2>
          (базовый тип в Cassandra)
          <pre><code>
            data LWW a = LWW
                { value :: a
                , time  :: Timestamp
                }

            instance Semigroup (LWW a) where
                x &lt;> y =
                    if time x > time y then
                        x
                    else
                        y

            instance Semilattice (LWW a)

            -- instance CvRDT (LWW a) -- автоматически
          </code></pre>
        </section>

        <section>
          <h2>Пример из реальности — счётчик лайков</h2>

          <table class="td-center">
            <tr>
              <td>
                <code>
                  <span class=f3>{</span><span class=f1>0:</span>
                  <span class=f0>717</span><span class=f3>, &nbsp;1: 826,
                  &nbsp;2: 273}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0: 717,</span>
                  <span class=f1>&nbsp;1:</span>
                  <span class=f0>826</span><span class=f3>,
                  &nbsp;2: 273}<br>&uarr;</span>
                </code>
              </td>
              <td>
                <code>
                  <span class=f3>{0: 717, &nbsp;1: 826,</span>
                  <span class=f1>&nbsp;2:</span>
                  <span class=f0>273</span><span class=f3>}<br>&uarr;</span>
                </code>
              </td>
            </tr>
          </table>

          <p class=f2>
            &darr;<br>
            <code>{0: 717, 1: 826, 2: 273}</code>
          </p>
        </section>

        <section>
          <h2>Grow-only counter</h2>

          <pre><code>
            newtype GCounter = G (Map ReplicaId Natural)

            increment :: ReplicaId -> GCounter -> GCounter
            increment replicaId (G m) =
                G (insertWith (+) replicaId 1 m)

            query :: GCounter -> Natural
            query (G m) = sum m

            instance Semigroup GCounter where
                G x &lt;> G y = G (unionWith max x y)

            instance Semilattice GCounter

            -- instance CvRDT GCounter -- автоматически
          </code></pre>
        </section>

        <section>
          <h1>Sequence types</h1>
          <h2>Treedoc, RGA, Woot, Logoot, LSEQ, Causal Tree...</h2>
        </section>

        <section>
          <h1>Проблема CvRDT&nbsp;— размер пересылаемых данных</h1>
        </section>

        <section>
          <h2><em>Commutative</em> RDT</h2>
          <h3>(CmRDT, op-based)</h3>
          <img
            alt="CmRDT"
            class=element
            height="500px"
            src="CmRDT-overview.svg"
            style="filter: invert(100%); box-shadow: none;">
        </section>

        <section>
          <h2>CmRDT в Haskell</h2>
          <pre><code>
            class CausalOrd op => CmRDT op where
                type Payload op
                apply :: op -> Payload op -> Payload op

                type Intent op
                makeOp :: Intent op -> Payload op -> Maybe (Process op)

            class CausalOrd a where
                affects :: a -> a -> Bool
          </code></pre>
          (да, чуть сложнее, чем CvRDT)
        </section>

        <!-- TODO: property for CmRDT -->

        <section>
          <h2><code>LWW</code> (Last Write Wins)</h2>
          <pre><code>
            data LWW a = LWW
                { value :: a
                , time  :: Timestamp
                }

            instance Eq a => CmRDT (LWW a) where
                type Payload (LWW a) = LWW a
                apply = (&lt;>)

                type Intent (LWW a) = a
                makeOp value state = Just (assign value state)
          </code></pre>
        </section>

        <section>
          <h2>Counter</h2>
          <pre><code>
            data Counter = Increment | Decrement

            instance CmRDT Counter where
                type Payload Counter = Integer
                apply op x = case op of
                    Increment -> x + 1
                    Decrement -> x - 1

                type Intent Counter = Counter
                makeOp i _ = Just (pure i)
          </code></pre>
        </section>

        <section>
          <h2>2P-Set (2-phase set)</h2>
          <pre><code>
            data TwoPSet a = Add a | Remove a

            instance Ord a => CmRDT (TwoPSet a) where
                type Payload (TwoPSet a) = Set a
                apply op s = case op of
                    Add    a  ->  insert a s
                    Remove a  ->  delete a s

                type Intent (TwoPSet a) = TwoPSet a
                makeOp op s = case op of
                    Remove a | a `notMember` s  ->  Nothing
                    _                           ->  Just (pure op)

            instance Eq a => CausalOrd (TwoPSet a) where
                Add a  `affects`  Remove b  =  a == b
                _      `affects`  _         =  False
          </code></pre>
          <!-- TODO: не очевидно, что CmRDT (2PSet) -->
        </section>

        <section data-markdown>
          # CRDT

          - Convergent (state-based)
          - Commutative (op-based)
          - Delta-state
          - Swarm RON
          - ...
        </section>

        <section data-markdown>
          # Haskell <nobr>не проверяет</nobr> законы классов
        </section>

        <section data-markdown>
          # Как убедить себя, что код правильный?
        </section>

        <section>
          <h2>Property-based testing (QuickCheck)</h2>

          <pre><code>
            associativity  =  \x y z  ->  (x &lt;> y) &lt;> z == x &lt;> (y &lt;> z)
            commutativity  =  \x y  ->  x &lt;> y == y &lt;> x
            idempotency    =  \x  ->  x &lt;> x == x
          </code></pre>

          <pre><code class="haskell">
            cvrdtLaws @(Set Char)
            cvrdtLaws @(Max Char)
            cvrdtLaws @GCounter
            ...
          </code></pre>

          <pre><code>
            associativity:
              +++ OK, passed 100 tests.
            commutativity:
              +++ OK, passed 100 tests.
            idempotency:
              +++ OK, passed 100 tests.
          </code></pre>
        </section>

        <section>
          <pre><code>
            LWW commutativity: FAIL
              *** Failed! Falsifiable (after 1 test):
              x = LWW {value = 'A', time = LamportTime 0 (Pid 0)}
              y = LWW {value = 'B', time = LamportTime 0 (Pid 0)}
              LWW {value = 'A', time = LamportTime 0 (Pid 0)} /=
                LWW {value = 'B', time = LamportTime 0 (Pid 0)}
          </code></pre>
          <pre><code>
            cvrdtLaws ::
                (Arbitrary a, CvRDT a, Eq a, Show a) =>
                Maybe (StateT s Gen a, s) -> [TestTree]
          </code></pre>
        </section>

        <section>
          <h2>Property-based testing (QuickCheck)</h2>
          <ul>
            <li>легко использовать</li>
            <li>нет 100% гарантии</li>
            <li>зависит от распределения</li>
          </ul>
        </section>

        <section>
          <h2>
            <a href="http://hackage.haskell.org/package/ClassLaws">
              <i class="icon-haskell"></i> <code>ClassLaws</code>
            </a>
          </h2>

          <a href="http://wiki.portal.chalmers.se/cse/pmwiki.php/FP/ClassLaws">
            wiki.portal.chalmers.se/<wbr>cse/<wbr>pmwiki.php/<wbr>FP/<wbr>ClassLaws</a>,
          2012

          <ul>
            <li class="fragment">
              дополнительный класс с законами на ваш класс
              <ul>
                <li class="fragment">надо вызывать QuickCheck руками</li>
              </ul>
            </li>
            <li class="fragment">
              DSL для формального доказательства, затем SMT-решатель
              <ul>
                <li class="fragment">есть проблеммы с рекурсией</li>
                <!-- TODO: почему у SMT проблемы с рекурсией? -->
              </ul>
            </li>
            <li class="fragment">не развивается с 2012 года</li>
          </ul>
        </section>

        <section>
          <h1>Liquid Haskell</h1>
          <ul>
            <li class="fragment">
              нет поддержки классов (такой, какой нам бы хотелось)
            </li>
            <!-- TODO: example -->
          </ul>
        </section>

        <section>
          <h1>Type-level</h1>
          <p>
            Justin Le,<br>
            <a href="https://blog.jle.im/entry/verified-instances-in-haskell.html">
              blog.jle.im/<wbr>entry/<wbr>verified-instances-in-haskell
            </a>
          </p>
        </section>

        <section>
          <h2>Ah, type-level Haskell...</h2>
          <pre><code>
            {-# LANGUAGE DataKinds #-}
            {-# LANGUAGE FlexibleInstances #-}
            {-# LANGUAGE GADTs #-}
            {-# LANGUAGE OverloadedStrings #-}
            {-# LANGUAGE PolyKinds #-}
            {-# LANGUAGE QuasiQuotes #-}
            {-# LANGUAGE RankNTypes #-}
            {-# LANGUAGE ScopedTypeVariables #-}
            {-# LANGUAGE TemplateHaskell #-}
            {-# LANGUAGE TypeFamilies #-}
            {-# LANGUAGE TypeOperators #-}
            {-# LANGUAGE UndecidableInstances #-}
          </code></pre>
        </section>

        <section>
          <h2>Полугруппа с доказательством</h2>
          <pre><code>
            class Semigroup a where
                type (x :: a) &lt;> (y :: a) :: a

                (%&lt;>) ::
                    Sing (x :: a) -> Sing (y :: a) -> Sing (x &lt;> y)

                associativity ::
                    Sing (x :: a) -> Sing (y :: a) -> Sing (z :: a) ->
                    ((x &lt;> y) &lt;> z) :~: (x &lt;> (y &lt;> z))

            (&lt;>) :: (SingKind m, Semigroup m) =>
                    Demote m -> Demote m -> Demote m
            x &lt;> y = withSomeSing x $ \sX ->
                         withSomeSing y $ \sY ->
                             fromSing (sX %&lt;> sY)
          </code></pre>
        </section>

        <section>
          <h2>Список с доказательством</h2>
          <pre><code>
            instance Semigroup [a] where
                type xs &lt;> ys = xs :++ ys
                (%&lt;>) = (%:++)

                associativity xs ys zs = case xs of
                    SNil -> Refl
                    SCons _ xs' ->
                        case associativity xs' ys zs of
                            Refl -> Refl
          </code></pre>
        </section>

        <section>
          <h2><code>Max</code> с доказательством</h2>
          <pre><code>
            instance SOrd a => Semigroup (Max a) where
                type 'Max x &lt;> 'Max y = 'Max (Singletons.Max x y)
                SMax x %&lt;> SMax y = SMax (sMax x y)
                associativity = undefined
          </code></pre>
        </section>

        <section>
          <h2>В действии</h2>
          <pre><code class="haskell">
            λ> print ([1, 2] &lt;> [3] :: [Integer])
            [1,2,3]
          </code></pre>
          <pre class="fragment"><code class="haskell">
            λ> print ([1, 2] &lt;> [3] :: [Int])
            error:
                • Couldn't match type ‘Demote a’ with ‘Int’
                  Expected type: [Int]
                    Actual type: Demote [a]
                  The type variable ‘a’ is ambiguous
          </code></pre>
          <pre class="fragment"><code class="haskell">
            λ> print ([1, 2] &lt;> [-3] :: [Integer])
            *** Exception: Negative singleton nat
          </code></pre>
        </section>

        <!-- TODO http://www.cse.chalmers.se/~jomoa/papers/typeclasslaws.pdf -->

        <!-- TODO: https://github.com/LeventErkok/sbvPlugin -->

        <section data-markdown>
          ## Выводы

          1. Property-based тестирование — вещь
          1. Dependent Haskell — не сегодня
          1. Liquid Haskell — тяжело, но стоит изучать
        </section>

        <section data-markdown>
          ## Планы на будущее

          1. Интегрировать с Antidote, Swarm
          1. ~~Написать~~ Дописать приложение, использующее CRDT
          1. Попробовать Coq
        </section>

        <section>
          <h1>Ваши вопросы</h1>
          <h2>Юрий Сыровецкий</h2>
          <h2>Николай Логинов</h2>
          <h2>
            <a href="https://hackage.haskell.org/package/crdt">
              <i class="icon-haskell"></i> <code>crdt</code>
            </a>
          </h2>
          <h2>
            <a href="https://github.com/cblp/crdt">
              <i class="icon-github"></i> <code>cblp/crdt</code>
            </a>
          </h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      document.querySelectorAll('[data-fragment-index]').forEach(e => {
        e.className += ' fragment';
      });

      document.querySelectorAll('code').forEach(e => {e.dataset.trim = '';});

      fragmentColors = ['#f55', '#ff5', '#5f5', '#5ff', '#55f', '#f5f'];
      for (var i = 0; i < 10; ++i) {
        document.querySelectorAll('[class=f' + i + ']').forEach(f => {
          f.className += ' fragment';
          f.dataset.fragmentIndex = i;
          f.style.color = fragmentColors[i];
        });
      }

      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        dependencies: [
          {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
              hljs.configure({languages: ['haskell']});
              hljs.initHighlightingOnLoad();
            }
          },
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/math/math.js' },
          { src: 'plugin/notes/notes.js', async: true },
        ],
        history: true,
        slideNumber: true,
        transition: 'fade',
      });
    </script>
  </body>
</html>

<!-- TODO: интонацией выделять переходы -->
<!-- TODO: контакт с аудиторией -->
<!-- TODO: код крупнее -->
